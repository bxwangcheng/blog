---
title: 字节序 —— 计算机大小端与网络序
date: 2020-03-08 13:35:16
categories:
- 技术
tags:
- 操作系统
---

多数x86体系计算机的字节序为小端，TCP/IP协议规定的字节序（网络序）为大端

![未标题-1.png](https://i.loli.net/2020/03/08/7TiNK3P9W8LwYMu.png)

<!--more-->

------

先说一个前提，数据在内存中存放的顺序是从低内存地址开始存放到高内存地址

32位程序的内存地址从0x0000到0xffff，一个内存地址存放1字节(8bit)的内容

对于0x01234567这样一个4字节的int数据，使用4个内存地址存放，假设从0x100存放到0x103

![](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016112201.gif)

大端：从数据的高位开始存放，0x01234567这个数据的高位是01

小端：从数据的低位开始存放，0x01234567这个数据的低位是67



再举个例子：对于一个int(1)二进制`0000 0000 0000 0000 0000 0000 0000 0001`

还使用刚才的内存地址

大端存放顺序：

| 0x100     | 0x101     | 0x102     | 0x103     |
| --------- | --------- | --------- | --------- |
| 0000 0000 | 0000 0000 | 0000 0000 | 0000 0001 |

小端存放顺序：

| 0x100     | 0x101     | 0x102     | 0x103     |
| --------- | --------- | --------- | --------- |
| 0000 0001 | 0000 0000 | 0000 0000 | 0000 0000 |

使用这个例子，用C++做个实验

```C++
// union中的成员共用内存地址，起始地址一样
union Endian {
    char one_byte; // char大小1字节，占用地址0x100
    int four_bytes; // int大小4字节，占用地址0x100 0x101 0x102 0x103
};

// 根据上面的分析，若one_byte为00000000则为大端机器，为00000001则为小端机器
Endian local;
local.four_bytes = 1;

cout << bitset<32>(local.four_bytes) << endl;
cout << bitset<8>(local.one_byte) << endl;
```

运行结果：

```
00000000 00000000 00000000 00000001
00000001
```

------

# 参考文献

[1] [理解字节序](URL 'https://www.ruanyifeng.com/blog/2016/11/byte-order.html')
[2] [“字节序”是个什么鬼？](URL 'https://zhuanlan.zhihu.com/p/21388517')